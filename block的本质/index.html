<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>block的本质 | yahao‘s note</title>
  <meta name="keywords" content="">
  <meta name="description" content="block的本质 | yahao‘s note">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="https://xieyahao.github.io/blog/hello-world/index.html">
<meta property="og:site_name" content="yahao‘s note">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-05-29T10:29:00.486Z">
<meta property="article:modified_time" content="2020-05-29T10:29:00.486Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
</div>


<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/" class="avatar_target">
    <img class="avatar" src="/blog/img/avatar.jpg" />
</a>
<div class="author">
    <span></span>
</div>

<div class="icon">
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(3)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 "
           href="/blog/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-05-29 18:29:00">2020/05/29</span>
        </a>
        
        <a  class="全部文章 "
           href="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="block的本质">block的本质</span>
            <span class="post-date" title="2020-05-29 18:29:00">2020/05/29</span>
        </a>
        
        <a  class="全部文章 "
           href="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="runtime学习一">runtime学习一</span>
            <span class="post-date" title="2020-05-28 15:43:26">2020/05/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-block的本质" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">block的本质</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-06-08 18:48:16'>2020-05-29 18:29</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、oc中的block"><span class="toc-text">一、oc中的block</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、把下面的代码，使用命令行-xcrun-sdk-iphonesimulator-clang-rewrite-objc-main-m-将main-m文件转化为C-查看内部结构。"><span class="toc-text">1、把下面的代码，使用命令行 xcrun -sdk iphonesimulator clang -rewrite-objc main.m 将main.m文件转化为C++查看内部结构。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、先看block-的定义："><span class="toc-text">2、先看block 的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、回过头来查看-main-block-impl-0结构体"><span class="toc-text">3、回过头来查看__main_block_impl_0结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、调用block执行内部代码"><span class="toc-text">4、调用block执行内部代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、如何验证block的本质确实是-main-block-impl-0结构体类型。"><span class="toc-text">5、如何验证block的本质确实是__main_block_impl_0结构体类型。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、block的变量捕获"><span class="toc-text">二、block的变量捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、局部变量"><span class="toc-text">1、局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、static变量"><span class="toc-text">2、static变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、全局变量"><span class="toc-text">3、全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、实例变量"><span class="toc-text">4、实例变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、block的类型"><span class="toc-text">三、block的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、block对象是什么类型呢？"><span class="toc-text">1、block对象是什么类型呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、block的三种类型"><span class="toc-text">2、block的三种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、block在内存中的存储"><span class="toc-text">3、block在内存中的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、block是如何定义其类型"><span class="toc-text">4、block是如何定义其类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、block作为函数返回值时"><span class="toc-text">a、block作为函数返回值时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、将block赋值给-strong指针时"><span class="toc-text">b、将block赋值给__strong指针时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、block作为Cocoa-API中方法名含有usingBlock的方法参数时"><span class="toc-text">c、block作为Cocoa API中方法名含有usingBlock的方法参数时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d、block作为GCD-API的方法参数时"><span class="toc-text">d、block作为GCD API的方法参数时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、block声明写法"><span class="toc-text">四、block声明写法</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#block的本质</p>
<h2 id="一、oc中的block"><a href="#一、oc中的block" class="headerlink" title="一、oc中的block"></a>一、oc中的block</h2><h3 id="1、把下面的代码，使用命令行-xcrun-sdk-iphonesimulator-clang-rewrite-objc-main-m-将main-m文件转化为C-查看内部结构。"><a href="#1、把下面的代码，使用命令行-xcrun-sdk-iphonesimulator-clang-rewrite-objc-main-m-将main-m文件转化为C-查看内部结构。" class="headerlink" title="1、把下面的代码，使用命令行 xcrun -sdk iphonesimulator clang -rewrite-objc main.m 将main.m文件转化为C++查看内部结构。"></a>1、把下面的代码，使用命令行 xcrun -sdk iphonesimulator clang -rewrite-objc main.m 将main.m文件转化为C++查看内部结构。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> (^yhBlock)(<span class="keyword">int</span> a,<span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b) &#123;</span><br><span class="line">            NSLog(@<span class="string">"%d"</span>, a + b );</span><br><span class="line">            NSLog(@<span class="string">"block内 age = %d"</span>, age );</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        NSLog(@<span class="string">"block 执行前age = %d"</span>, age );</span><br><span class="line"></span><br><span class="line">        yhBlock(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">             </span><br><span class="line">        NSLog(@<span class="string">"block 执行后age = %d"</span>, age );</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, <span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_tl_9wc89m9x72x0tlbwylxrqk140000gn_T_main_c2896e_mi_0, a + b );</span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_tl_9wc89m9x72x0tlbwylxrqk140000gn_T_main_c2896e_mi_1, age );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*yhBlock)(<span class="keyword">int</span> a,<span class="keyword">int</span> b) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_tl_9wc89m9x72x0tlbwylxrqk140000gn_T_main_c2896e_mi_2, age );</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>, <span class="keyword">int</span>))((__block_impl *)yhBlock)-&gt;FuncPtr)((__block_impl *)yhBlock, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_tl_9wc89m9x72x0tlbwylxrqk140000gn_T_main_c2896e_mi_3, age );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、先看block-的定义："><a href="#2、先看block-的定义：" class="headerlink" title="2、先看block 的定义："></a>2、先看block 的定义：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*yhBlock)(<span class="keyword">int</span> a,<span class="keyword">int</span> b) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure>
<p>调用了 <strong>main_block_impl_0 方法，并把这个函数的地址赋给了 block。该函数还包含了三个参数。看一下</strong>main_block_impl_0的内部构造：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>包含一个同名构造函数<strong>main_block_impl_0，对一些变量赋值最终返回的是这个结构体。block = 返回的</strong>main_block_impl_0结构体地址。</p>
<p>参数分析：<br>第一个参数：<strong>main_block_func_0，找到定义发现了两个熟悉的NSLog，这两段代码恰恰是我们在block块中写下的代码。 那么</strong>main_block_func_0函数中其实存储着我们block中写下的代码，也就是；<br>写在block块中的代码封装成<strong>main_block_func_0函数，并将</strong>main_block_func_0函数的地址传入了__main_block_impl_0的构造函数中保存在结构体内。</p>
<p>第二个参数：&amp;__main_block_desc_0_DATA<br>查看内部结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>main_block_desc_0中存储着两个参数，reserved和Block_size，并且reserved赋值为0，而Block_size则存储着</strong>main_block_impl_0的占用空间大小。构造函数中，将<strong>main_block_desc_0结构体的地址传入</strong>main_block_func_0中赋值给Desc。</p>
<p>第三个参数：age<br>age也就是我们定义的局部变量。因为在block块中使用到age局部变量，所以在block声明的时候这里才会将age作为参数传入，也就说block会捕获age，如果没有在block中使用age，这里将只会传入(void *)<strong>main_block_func_0，&amp;</strong>main_block_desc_0_DATA两个参数。</p>
<p>Q ：为什么当我们在定义block之后修改局部变量age的值，在block调用的时候无法生效？<br>A ： 因为block在定义的之后已经将age的值传入存储在__main_block_imp_0结构体中并在调用的时候将age从block中取出来使用，因此在block定义之后对局部变量进行改变是无法被block捕获的。</p>
<h3 id="3、回过头来查看-main-block-impl-0结构体"><a href="#3、回过头来查看-main-block-impl-0结构体" class="headerlink" title="3、回过头来查看__main_block_impl_0结构体"></a>3、回过头来查看__main_block_impl_0结构体</h3>



<p><strong>block_impl结构体内部就有一个isa指针。因此可以证明block本质上就是一个oc对象。而在构造函数中将函数中传入的值分别存储在</strong>main_block_impl_0结构体实例中，最终将结构体的地址赋值给block。</p>
<p>上面对__main_block_impl_0结构体构造函数三个参数的分析我们可以得出结论：</p>
<ol>
<li>__block_impl结构体中isa指针存储着&amp;_NSConcreteStackBlock地址，可以暂时理解为其类对象地址，block就是_NSConcreteStackBlock类型的。</li>
<li>block代码块中的代码被封装成<strong>main_block_func_0函数，FuncPtr则存储着</strong>main_block_func_0函数的地址。</li>
<li>Desc指向<strong>main_block_desc_0结构体对象，其中存储</strong>main_block_impl_0结构体所占用的内存。</li>
</ol>
<h3 id="4、调用block执行内部代码"><a href="#4、调用block执行内部代码" class="headerlink" title="4、调用block执行内部代码"></a>4、调用block执行内部代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>, <span class="keyword">int</span>))((__block_impl *)yhBlock)-&gt;FuncPtr)((__block_impl *)yhBlock, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以发现,调用block是通过block找到FunPtr直接调用，通过上面分析我们知道block指向的是<strong>main_block_impl_0类型结构体，但是我们发现</strong>main_block_impl_0结构体中并不直接就可以找到FunPtr，而FunPtr是存储在<strong>block_impl中的，为什么block可以直接调用</strong>block_impl中的FunPtr呢？</p>
<p>重新查看上述源代码可以发现，(<strong>block_impl *)block将block强制转化为</strong>block_impl类型的，因为<strong>block_impl是</strong>main_block_impl_0结构体的第一个成员，相当于将<strong>block_impl结构体的成员直接拿出来放在</strong>main_block_impl_0中，那么也就说明<strong>block_impl的内存地址就是</strong>main_block_impl_0结构体的内存地址开头。所以可以转化成功。并找到FunPtr成员。</p>
<p>上面我们知道，FunPtr中存储着通过代码块封装的函数地址，那么调用此函数，也就是会执行代码块中的代码。</p>
<p>查看<strong>main_block_func_0函数，可以发现第一个参数就是</strong>main_block_impl_0类型的指针。也就是说将block传入__main_block_func_0函数中，便于重中取出block捕获的值。</p>
<h3 id="5、如何验证block的本质确实是-main-block-impl-0结构体类型。"><a href="#5、如何验证block的本质确实是-main-block-impl-0结构体类型。" class="headerlink" title="5、如何验证block的本质确实是__main_block_impl_0结构体类型。"></a>5、如何验证block的本质确实是__main_block_impl_0结构体类型。</h3><p> 同样使用之前的方法，我们按照上面分析的block内部结构自定义结构体，并将block内部的结构体强制转化为自定义的结构体，转化成功说明底层结构体确实如我们之前分析的一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span> </span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模仿系统__main_block_impl_0结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">int</span> ,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">            NSLog(@<span class="string">"this is block,a = %d,b = %d"</span>,a,b);</span><br><span class="line">            NSLog(@<span class="string">"this is block,age = %d"</span>,age);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">// 将底层的结构体强制转化为我们自己写的结构体，通过我们自定义的结构体探寻block底层结构体</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blockStruct</span> = (__<span class="title">bridge</span> <span class="title">struct</span> __<span class="title">main_block_impl_0</span> *)<span class="title">block</span>;</span></span><br><span class="line">        block(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，没问题，查看 调用栈地址，发现分析的也没问题。总结图：</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E5%BA%95%E5%B1%82struct%E5%9B%BE.png" class="" title="block底层struct图.png">

<h2 id="二、block的变量捕获"><a href="#二、block的变量捕获" class="headerlink" title="二、block的变量捕获"></a>二、block的变量捕获</h2><p>为了保证block内部能够正常访问外部的变量，block有一个变量捕获机制。</p>
<h3 id="1、局部变量"><a href="#1、局部变量" class="headerlink" title="1、局部变量"></a>1、局部变量</h3><p>auto自动变量，离开作用域就销毁，通常局部变量前面自动添加auto关键字。自动变量会捕获到block内部，也就是说block内部会专门新增加一个参数来存储变量的值。<br>auto只存在于局部变量中，访问方式为值传递，通过上述对age参数的解释我们也可以确定确实是值传递。</p>
<h3 id="2、static变量"><a href="#2、static变量" class="headerlink" title="2、static变量"></a>2、static变量</h3><p>static 修饰的变量为指针传递，同样会被block捕获。</p>
<p>接下来分别添加aotu修饰的局部变量和static修饰的局部变量，重看源码来看一下他们之间的差别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^yhBlock)(<span class="keyword">void</span>) = ^() &#123;</span><br><span class="line">   NSLog(@<span class="string">"block内 a = %d,b = %d"</span>, a,b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">NSLog(@<span class="string">"block 执行前a = %d,b = %d"</span>, a ,b);</span><br><span class="line">yhBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//log:</span></span><br><span class="line"><span class="comment">//2020-06-08 14:32:55.105905+0800 myRuntimeStudy[27860:6464106] block 执行前a = 1,b = 2</span></span><br><span class="line"><span class="comment">//2020-06-08 14:32:55.109104+0800 myRuntimeStudy[27860:6464106] block内 a = 10,b = 2</span></span><br></pre></td></tr></table></figure>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E5%AF%B9%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8C%BA%E5%88%AB.png" class="" title="block对静态变量与局部变量捕获的区别.png">
<p>上述源码中可以看出，a,b两个变量都有捕获到block内部。但是a传入的是值，而b传入的则是地址。<br>为什么两种变量会有这种差异呢，因为自动变量可能会销毁，block在执行的时候有可能自动变量已经被销毁了，那么此时如果再去访问被销毁的地址肯定会发生坏内存访问，因此对于自动变量一定是值传递而不可能是指针传递了。而静态变量不会被销毁，所以完全可以传递地址。而因为传递的是值得地址，所以在block调用之前修改地址中保存的值，block中的地址是不会变得。所以值会随之改变。</p>
<h3 id="3、全局变量"><a href="#3、全局变量" class="headerlink" title="3、全局变量"></a>3、全局变量</h3><p>修改成如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">void</span> (^yhBlock)(<span class="keyword">void</span>) = ^() &#123;</span><br><span class="line">            NSLog(@<span class="string">"block内 a = %d,b = %d"</span>, a,b);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        NSLog(@<span class="string">"block 执行前a = %d,b = %d"</span>, a ,b);</span><br><span class="line">        yhBlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2020-06-08 15:04:02.109912+0800 myRuntimeStudy[27975:6478909] block 执行前a = 1,b = 2</span></span><br><span class="line"><span class="comment">// 2020-06-08 15:04:02.127486+0800 myRuntimeStudy[27975:6478909] block内 a = 1,b = 2</span></span><br></pre></td></tr></table></figure>
<p>同样生成c++代码查看全局变量调用方式:</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E5%AF%B9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8.png" class="" title="block对全局变量引用.png">
<p>通过上述代码可以发现，__main_block_imp_0并没有添加任何变量，因此block不需要捕获全局变量，因为全局变量无论在哪里都可以访问。</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E5%AF%B9%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8%E8%A1%A8.png" class="" title="block对各种变量的引用表.png">
<p>总结：局部变量都会被block捕获，自动变量是值捕获，静态变量为地址捕获。全局变量则不会被block捕获</p>
<h3 id="4、实例变量"><a href="#4、实例变量" class="headerlink" title="4、实例变量"></a>4、实例变量</h3><p>新建person类，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,self);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>) test2</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"类方法test2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样转化为c++代码查看其内部结构:</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8Fself%E5%BC%95%E7%94%A8%E6%BA%90%E7%A0%81.png" class="" title="block实例变量self引用源码.png">
<p>上图中可以发现，self同样被block捕获，接着我们找到test方法可以发现，test方法默认传递了两个参数self和_cmd。而类方法test2也同样默认传递了类对象self和方法选择器_cmd.</p>
<p>![类方法与实例方法参数的对比.png](block的本质/类方法与实例方法参数的对比.png<br>g)<br>不论对象方法还是类方法都会默认将self作为参数传递给方法内部，既然是作为参数传入，那么self肯定是局部变量。上面讲到局部变量肯定会被block捕获。</p>
<p>接下来看下，如果在block中使用成员变量或者调用实例的属性会有什么不同的结果：<br>修改test方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,self.name);</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,self-&gt;_name);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![属性和实例变量不同获取方式对比.png](block的本质/属性和实例变量不同获取方式对比.png）<br>上图中可以发现，即使block中使用的是实例对象的属性，block中捕获的仍然是实例对象self，并通过实例对象通过不同的方式去获取使用到的属性。</p>
<h2 id="三、block的类型"><a href="#三、block的类型" class="headerlink" title="三、block的类型"></a>三、block的类型</h2><h3 id="1、block对象是什么类型呢？"><a href="#1、block对象是什么类型呢？" class="headerlink" title="1、block对象是什么类型呢？"></a>1、block对象是什么类型呢？</h3><p>首先知道了block 指针是 指向_NSConcreteStackBlock类对象地址的。那么block是否就是_NSConcreteStackBlock类型的呢？</p>
<p>通过代码用class方法或者isa指针查看具体类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">// __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</span></span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"Hello"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">                </span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, [block class]);</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, [[block class] superclass]);</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, [[[block class] superclass] superclass]);</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, [[[[block class] superclass] superclass] superclass]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2020-06-08 17:20:23.811767+0800 myRuntimeStudy[28481:6550993] __NSGlobalBlock__</span></span><br><span class="line"><span class="comment">// 2020-06-08 17:20:23.816262+0800 myRuntimeStudy[28481:6550993] __NSGlobalBlock</span></span><br><span class="line"><span class="comment">// 2020-06-08 17:20:23.816409+0800 myRuntimeStudy[28481:6550993] NSBlock</span></span><br><span class="line"><span class="comment">// 2020-06-08 17:20:23.816558+0800 myRuntimeStudy[28481:6550993] NSObject</span></span><br></pre></td></tr></table></figure>
<p>从上述打印内容可以看出block最终都是继承自NSBlock类型，而NSBlock继承于NSObjcet。那么block其中的isa指针其实是来自NSObject中的。这也更加印证了block的本质其实就是OC对象.</p>
<h3 id="2、block的三种类型"><a href="#2、block的三种类型" class="headerlink" title="2、block的三种类型"></a>2、block的三种类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）</span><br><span class="line">__NSStackBlock__ （ _NSConcreteStackBlock ）</span><br><span class="line">__NSMallocBlock__ （ _NSConcreteMallocBlock ）</span><br></pre></td></tr></table></figure>
<p>通过代码查看一下block在什么情况下其类型会各不相同:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">// 1. 内部没有调用外部变量的block</span></span><br><span class="line">        <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"Hello"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 2. 内部调用外部变量的block</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"Hello - %d"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="comment">// 3. 直接调用的block的class</span></span><br><span class="line">        NSLog(@<span class="string">"%@ %@ %@"</span>, [block1 class], [block2 class], [^&#123;</span><br><span class="line">            NSLog(@<span class="string">"%d"</span>,a);</span><br><span class="line">        &#125; class]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过打印内容确实可以发现block的三种类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__   __NSMallocBlock__   __NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>注：上述代码转化为c++代码查看源码时却发现block的类型与打印出来的类型不一样，c++源码中三个block的isa指针全部都指向_NSConcreteStackBlock类型地址。<br>我们可以猜测runtime运行时过程中也许对类型进行了转变。最终类型当然以runtime运行时类型也就是我们打印出的类型为准。</p>
<h3 id="3、block在内存中的存储"><a href="#3、block在内存中的存储" class="headerlink" title="3、block在内存中的存储"></a>3、block在内存中的存储</h3><p>通过下面一张图看一下不同block的存放区域：</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/%E4%B8%8D%E5%90%8Cblock%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE%E5%8C%BA%E5%9F%9F.png" class="" title="block不同类型的特点与存储区域对比.png">

<p>上图中可以发现，根据block的类型不同，block存放在不同的区域中。</p>
<p>数据段中的<strong>NSGlobalBlock</strong>直到程序结束才会被回收，不过我们很少使用到<strong>NSGlobalBlock</strong>类型的block，因为这样使用block并没有什么意义。</p>
<p><strong>NSStackBlock</strong>类型的block存放在栈中，我们知道栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放，而在相同的作用域中定义block并且调用block似乎也多此一举。</p>
<p><strong>NSMallocBlock</strong>是在平时编码过程中最常使用到的。存放在堆中需要我们自己进行内存管理。</p>
<h3 id="4、block是如何定义其类型"><a href="#4、block是如何定义其类型" class="headerlink" title="4、block是如何定义其类型"></a>4、block是如何定义其类型</h3><p>block是依据什么来为block定义不同的类型并分配在不同的空间呢？<br>首先看下面一张图</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%AF%B9%E6%AF%94.png" class="" title="block不同类型的特点与存储区域对比.png">
<p>接着我们使用代码验证上述问题，首先关闭ARC回到MRC环境下，因为ARC会帮助我们做很多事情，可能会影响我们的观察。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">     <span class="comment">// Global：没有访问auto变量：__NSGlobalBlock__</span></span><br><span class="line">        <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"block1---------"</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// Stack：访问了auto变量： __NSStackBlock__</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">                NSLog(@<span class="string">"block2---------%d"</span>, a);</span><br><span class="line">            &#125;;</span><br><span class="line">            NSLog(@<span class="string">"%@ %@"</span>, [block1 class], [block2 class]);</span><br><span class="line">            <span class="comment">// __NSStackBlock__调用copy ： __NSMallocBlock__</span></span><br><span class="line">            NSLog(@<span class="string">"%@"</span>, [[block2 copy] class]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log:</span></span><br><span class="line"><span class="comment">//2020-06-08 18:08:24.562043+0800 myRuntimeStudy[28705:6574673] __NSGlobalBlock__ __NSStackBlock__</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:08:24.562781+0800 myRuntimeStudy[28705:6574673] __NSMallocBlock__</span></span><br></pre></td></tr></table></figure>
<p>通过打印的内容可以发现正如上图中所示。<br>没有访问auto变量的block是<strong>NSGlobalBlock</strong>类型的，存放在数据段中。<br>访问了auto变量的block是<strong>NSStackBlock</strong>类型的，存放在栈中。<br><strong>NSStackBlock</strong>类型的block调用copy成为<strong>NSMallocBlock</strong>类型并被复制存放在堆中。</p>
<p><strong>NSGlobalBlock</strong>类型的我们很少使用到，因为如果不需要访问外界的变量，直接通过函数实现就可以了，不需要使用block。<br>但是<strong>NSStackBlock</strong>访问了aotu变量，并且是存放在栈中的，上面提到过，栈中的代码在作用域结束之后内存就会被销毁，那么我们很有可能block内存销毁之后才去调用他，那样就会发生问题.<br>通过下面代码可以证实这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// __NSStackBlock__</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block---------%d"</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">      test();</span><br><span class="line">      block();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log:</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:13:35.889505+0800 myRuntimeStudy[28727:6578019] block----------412841048</span></span><br></pre></td></tr></table></figure>
<p>a的值变为了不可控的一个数字。为什么会发生这种情况呢？因为上述代码中创建的block是<strong>NSStackBlock</strong>类型的，因此block是存储在栈中的，那么当test函数执行完毕之后，栈内存中block所占用的内存已经被系统回收，因此就有可能出现乱得数据。</p>
<p>查看其c++代码可以更清楚的理解。</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/MRC%E4%B8%8Bblock%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%87%8A%E6%94%BE%E5%BC%95%E8%B5%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E9%94%99%E4%B9%B1.png" class="" title="MRC下block引用成员变量释放引起的数据错乱.png">

<p>为了避免这种情况发生，可以通过copy将<strong>NSStackBlock</strong>类型的block转化为<strong>NSMallocBlock</strong>类型的block，将block存储在堆中，以下是修改后的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// __NSStackBlock__ 调用copy 转化为__NSMallocBlock__</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    block = [^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block---------%d"</span>, age);</span><br><span class="line">    &#125; copy];</span><br><span class="line">    [block <span class="built_in">release</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在打印就会发现数据正确.<br>那么其他类型的block调用copy会改变block类型吗？下面表格已经展示的很清晰了。</p>
<img src="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/MRC%E4%B8%8Bcopy%E6%93%8D%E4%BD%9C%E5%AF%B9block%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%B1%E5%93%8D.png" class="" title="MRC下copy操作对block类型的影响.png">
<p>所以在平时开发过程中MRC环境下经常需要使用copy来保存block，将栈上的block拷贝到堆中，即使栈上的block被销毁，堆上的block也不会被销毁，需要我们自己调用release操作来销毁。而在ARC环境下系统会自动调用copy操作，使block不会被销毁。</p>
<p>5、ARC帮我们做了什么<br>在ARC环境下，编译器会根据情况自动将栈上的block进行一次copy操作，将block复制到堆上。<br>什么情况下ARC会自动将block进行一次copy操作？</p>
<h4 id="a、block作为函数返回值时"><a href="#a、block作为函数返回值时" class="headerlink" title="a、block作为函数返回值时"></a>a、block作为函数返回值时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^Block)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Block <span class="title">myblock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 上文提到过，block中访问了auto变量，此时block类型应为__NSStackBlock__</span></span><br><span class="line">    Block block = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"---------%d"</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">    Block block = myblock();</span><br><span class="line">    block();</span><br><span class="line">    <span class="comment">// 打印block类型为 __NSMallocBlock__</span></span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,[block class]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log:</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:23:05.118309+0800 myRuntimeStudy[28809:6585087] ---------10</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:23:05.119251+0800 myRuntimeStudy[28809:6585087] __NSMallocBlock__</span></span><br></pre></td></tr></table></figure>
<p>上述代码 在MRC环境下会崩溃在，查看调用栈在msgsend ，[block class]处崩溃。在ARC下还可以打印出争取的值。</p>
<p>根据上文，如果在block中访问了auto变量时，block的类型为<strong>NSStackBlock</strong>，上面打印内容发现blcok为<strong>NSMallocBlock</strong>类型的，并且可以正常打印出a的值，说明block内存并没有被销毁。</p>
<p>上面提到过，block进行copy操作会转化为<strong>NSMallocBlock</strong>类型，来讲block复制到堆中，那么说明RAC在 block作为函数返回值时会自动帮助我们对block进行copy操作，以保存block，并在适当的地方进行release操作。</p>
<h4 id="b、将block赋值给-strong指针时"><a href="#b、将block赋值给-strong指针时" class="headerlink" title="b、将block赋值给__strong指针时"></a>b、将block赋值给__strong指针时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    <span class="comment">// block内没有访问auto变量</span></span><br><span class="line">          Block block = ^&#123;</span><br><span class="line">              NSLog(@<span class="string">"block---------"</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">          NSLog(@<span class="string">"%@"</span>,[block class]);</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">          <span class="comment">// block内访问了auto变量，但没有赋值给__strong指针</span></span><br><span class="line">          NSLog(@<span class="string">"%@"</span>,[^&#123;</span><br><span class="line">              NSLog(@<span class="string">"block1---------%d"</span>, a);</span><br><span class="line">          &#125; class]);</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// block赋值给__strong指针</span></span><br><span class="line">          Block block2 = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"block2---------%d"</span>, a);</span><br><span class="line">          &#125;;</span><br><span class="line">        </span><br><span class="line">          NSLog(@<span class="string">"block2 class = %@"</span>,[block2 class]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log:</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:40:03.586427+0800 myRuntimeStudy[28902:6594783] __NSGlobalBlock__</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:40:03.587368+0800 myRuntimeStudy[28902:6594783] __NSStackBlock__</span></span><br><span class="line"><span class="comment">// 2020-06-08 18:40:03.587501+0800 myRuntimeStudy[28902:6594783] block2 class = __NSMallocBlock__</span></span><br></pre></td></tr></table></figure>



<h4 id="c、block作为Cocoa-API中方法名含有usingBlock的方法参数时"><a href="#c、block作为Cocoa-API中方法名含有usingBlock的方法参数时" class="headerlink" title="c、block作为Cocoa API中方法名含有usingBlock的方法参数时"></a>c、block作为Cocoa API中方法名含有usingBlock的方法参数时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = @[];</span><br><span class="line">[<span class="built_in">array</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull <span class="built_in">stop</span>) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="d、block作为GCD-API的方法参数时"><a href="#d、block作为GCD-API的方法参数时" class="headerlink" title="d、block作为GCD API的方法参数时"></a>d、block作为GCD API的方法参数时</h4><p>例如：GDC的一次性函数或延迟执行的函数，执行完block操作之后系统才会对block进行release操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">            </span><br><span class="line">&#125;);        </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">1.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="四、block声明写法"><a href="#四、block声明写法" class="headerlink" title="四、block声明写法"></a>四、block声明写法</h2><p>通过上面对MRC及ARC环境下block的不同类型的分析，总结出不同环境下block属性建议写法。<br>MRC下block属性的建议写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>ARC下block属性的建议写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line">@property (copy, nonatomic) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

<p>以上主要是学习笔记，主要来自：<a href="https://juejin.im/post/5b0181e15188254270643e88" target="_blank" rel="noopener">https://juejin.im/post/5b0181e15188254270643e88</a></p>
<p><a href="https://yuxiang.ren/2019/04/16/Block/" target="_blank" rel="noopener">https://yuxiang.ren/2019/04/16/Block/</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
