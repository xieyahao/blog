<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>runtime学习一 | yahao‘s note</title>
  <meta name="keywords" content="">
  <meta name="description" content="runtime学习一 | yahao‘s note">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="https://xieyahao.github.io/blog/hello-world/index.html">
<meta property="og:site_name" content="yahao‘s note">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-05-29T10:29:00.486Z">
<meta property="article:modified_time" content="2020-05-29T10:29:00.486Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
</div>


<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/" class="avatar_target">
    <img class="avatar" src="/blog/img/avatar.jpg" />
</a>
<div class="author">
    <span></span>
</div>

<div class="icon">
    
</div>




<ul>
    <li><div class="all active" data-rel="All">All<small>(3)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">About</a><a style="width: 50%"  class="friends">Friends</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="All "
           href="/blog/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-05-29 18:29:00">2020/05/29</span>
        </a>
        
        <a  class="All "
           href="/blog/block%E7%9A%84%E6%9C%AC%E8%B4%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-05-29 18:29:00">2020/05/29</span>
        </a>
        
        <a  class="All "
           href="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="runtime学习一">runtime学习一</span>
            <span class="post-date" title="2020-05-28 15:43:26">2020/05/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-runtime学习一" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">runtime学习一</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2020-06-07 10:30:15'>2020-05-28 15:43</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#runtime"><span class="toc-text">runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime-又叫运行时，是一套底层C语言APi。"><span class="toc-text">runtime 又叫运行时，是一套底层C语言APi。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、类、对象-、函数"><span class="toc-text">一、类、对象 、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、类-objc-class"><span class="toc-text">1 、类 objc_class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、元类（meta-class）"><span class="toc-text">2、元类（meta class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、对象id-–-gt-objc-object"><span class="toc-text">3、对象id –&gt; objc_object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、objc-class中-cache-t-的实现"><span class="toc-text">4、objc_class中 cache_t 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-class-data-bits-t的具体实现"><span class="toc-text">5.class_data_bits_t的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、class-rw-t-与-class-ro-t"><span class="toc-text">a、class_rw_t 与 class_ro_t</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#aa、初印象"><span class="toc-text">aa、初印象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bb、class-ro-t-编译期"><span class="toc-text">bb、class_ro_t 编译期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cc、class-rw-t生成时机"><span class="toc-text">cc、class_rw_t生成时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dd、分类方法加载到class-rw-t的流程"><span class="toc-text">dd、分类方法加载到class_rw_t的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#objc-init"><span class="toc-text">_objc_init</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#然后：map-images-函数"><span class="toc-text">然后：map_images 函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#read-images"><span class="toc-text">_read_images</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#load-images"><span class="toc-text">load_images</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#loadable-classes是怎么管理的？"><span class="toc-text">loadable_classes是怎么管理的？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><h2 id="runtime-又叫运行时，是一套底层C语言APi。"><a href="#runtime-又叫运行时，是一套底层C语言APi。" class="headerlink" title="runtime 又叫运行时，是一套底层C语言APi。"></a>runtime 又叫运行时，是一套底层C语言APi。</h2><h2 id="一、类、对象-、函数"><a href="#一、类、对象-、函数" class="headerlink" title="一、类、对象 、函数"></a>一、类、对象 、函数</h2><h3 id="1-、类-objc-class"><a href="#1-、类-objc-class" class="headerlink" title="1 、类 objc_class"></a>1 、类 objc_class</h3><p> 在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在NSObject中观察到，</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/NSObject%E7%B1%BB%E5%AE%9A%E4%B9%89%E6%88%AA%E5%9B%BE.png" class="" title="NSObject类定义截图.png">

<p>看下class</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>

<p>Objc2.0 后，objc_class的定义：</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/objc_class%E5%AE%9A%E4%B9%89.png" class="" title="objc_class定义.png">
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/objc_class%E7%B1%BB%E5%9B%BE.png" class="" title="objc_class类图.png">

<h3 id="2、元类（meta-class）"><a href="#2、元类（meta-class）" class="headerlink" title="2、元类（meta class）"></a>2、元类（meta class）</h3><p>元类的引入，是为了和对象查找方法的机制一致。<br>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/isa_class_metaClass.png" class="" title="isa_class_metaClass.png">

<p>a.Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。<br>b.每个Class都有一个isa指针指向唯一的Meta class<br>c.Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。<br>d.每个Meta class的isa指针都指向Root class (meta)。</p>
<h3 id="3、对象id-–-gt-objc-object"><a href="#3、对象id-–-gt-objc-object" class="headerlink" title="3、对象id –&gt; objc_object"></a>3、对象id –&gt; objc_object</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line"><span class="comment">/// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line"><span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initIsa</span><span class="params">(Class cls <span class="comment">/*indexed=false*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInstanceIsa</span><span class="params">(Class cls, <span class="keyword">bool</span>    hasCxxDtor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initIsa</span><span class="params">(Class newCls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>isa_t 是一个union联合体。初始化isa时，对于64位的引入，为了节省内存和提高执行效率，苹果提出了tagged pointer.</p>
<h3 id="4、objc-class中-cache-t-的实现"><a href="#4、objc-class中-cache-t-的实现" class="headerlink" title="4、objc_class中 cache_t 的实现"></a>4、objc_class中 cache_t 的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">  <span class="keyword">mask_t</span> _mask;</span><br><span class="line">  <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">/// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">  IMP _imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/cache_t%E7%B1%BB%E5%9B%BE.png" class="" title="cache_t类图.png">
<p>mask：分配用来缓存bucket的总数。<br>occupied：表明目前实际占用的缓存bucket的个数。</p>
<p>bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。<br>Cache的作用主要是为了优化方法调用的性能。使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p>
<h3 id="5-class-data-bits-t的具体实现"><a href="#5-class-data-bits-t的具体实现" class="headerlink" title="5.class_data_bits_t的具体实现"></a>5.class_data_bits_t的具体实现</h3><img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/class_rw_t%E7%9A%84%E4%BD%BF%E7%94%A8.png" class="" title="class_rw_t的使用.png">

<h4 id="a、class-rw-t-与-class-ro-t"><a href="#a、class-rw-t-与-class-ro-t" class="headerlink" title="a、class_rw_t 与 class_ro_t"></a>a、class_rw_t 与 class_ro_t</h4><img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/class_rw_t%E4%B8%8Eclass_ro_t1.png" class="" title="class_rw_t与class_ro_t1.png.png">

<h5 id="aa、初印象"><a href="#aa、初印象" class="headerlink" title="aa、初印象"></a>aa、初印象</h5><p>class_ro_t存储了当前类在编译期就已经确定了的属性、方法和遵循的协议，里面是没有category的方法。运行时添加的方法将会存储在运行时生成的class_rw_t中。class_ro_t定义源码：</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/class_ro_t%E5%AE%9A%E4%B9%89.png" class="" title="class_ro_t定义">


<p>class_rw_t定义源码</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/class_rw_t%E5%AE%9A%E4%B9%89.png" class="" title="class_rw_t定义">

<p>总结起来的类图</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/class_data_bits_t%E7%B1%BB%E5%9B%BE.png" class="" title="class_data_bits_t类图.png">


<h5 id="bb、class-ro-t-编译期"><a href="#bb、class-ro-t-编译期" class="headerlink" title="bb、class_ro_t 编译期"></a>bb、class_ro_t 编译期</h5><p>在编译期类的结构中的 class_data_bits_t *data指向的是一个 class_ro_t *指针， 类图如下：</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/%E7%BC%96%E8%AF%91%E6%9C%9Fbit%E6%8C%87%E5%90%91%E7%B1%BB%E5%9B%BE.png" class="" title="编译期bit指向类图.png">

<h5 id="cc、class-rw-t生成时机"><a href="#cc、class-rw-t生成时机" class="headerlink" title="cc、class_rw_t生成时机"></a>cc、class_rw_t生成时机</h5><p>class_rw_t生成在运行时,在runtime运行之后，具体说来是在运行runtime的realizeClass 方法时，会生成class_rw_t结构体，该结构体包含了class_ro_t，并且更新data部分，换成class_rw_t结构体的地址。</p>
<p>realizeClass部分源码</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/realizeClass%E6%BA%90%E7%A0%81.png" class="" title="realizeClass源码.png">


<p>运行期bit指向类图；</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/%E8%BF%90%E8%A1%8C%E6%9C%9Fbit%E6%8C%87%E5%90%91%E7%B1%BB%E5%9B%BE.png" class="" title="运行期bit指向类图.png">

<h5 id="dd、分类方法加载到class-rw-t的流程"><a href="#dd、分类方法加载到class-rw-t的流程" class="headerlink" title="dd、分类方法加载到class_rw_t的流程"></a>dd、分类方法加载到class_rw_t的流程</h5><p>程序启动后，通过编译之后，Runtime 会进行初始化，调用 _objc_init.</p>
<h6 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h6><p>1、_objc_init由dylb驱动，这个阶段会注册三个回调,mapped、init、unmapped<br>再去检查是否有分类，同时将分类的方法，属性，协议列表整合存储在class_rw_t的方法，属性及协议列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init(); <span class="comment">//环境调试 例如僵尸模式设置后，就是在这里起作用的</span></span><br><span class="line">    tls_init(); <span class="comment">//tls指的是局部线程存储，可以将数据存储在线程一个公共区域，例如pthread_setspecific()，在autoreleasepool和堆栈信息获取时都有涉及</span></span><br><span class="line">    static_init(); <span class="comment">//执行c++静态构造函数</span></span><br><span class="line">    lock_init(); <span class="comment">//这里获取两个的线程优先级 后台优先级线程以及主线程</span></span><br><span class="line">    exception_init(); <span class="comment">//这里初始化libobjc的exception处理系统</span></span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="然后：map-images-函数"><a href="#然后：map-images-函数" class="headerlink" title="然后：map_images 函数"></a>然后：map_images 函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>接下来调用 map_images_nolock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.... 略去一大块</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h6><p>调用 _read_images,这个方法会读取所有类的相关信息，根据注释，主要做了：<br>_read_images 方法写了很长，其实就是做了一件事，将Mach-O文件的section依次读取，并根据内容初始化runtime的内存结构。</p>
<p> 1、加载所有类到类的gdb_objc_realized_classes表中。<br> 2、对所有类做重映射。<br> 3、将所有SEL都注册到namedSelectors表中。<br> 4、修复函数指针遗留。<br> 5、将所有Protocol都添加到protocol_map表中。<br> 6、对所有Protocol做重映射。<br> 7、初始化所有非懒加载的类，进行rw、ro等操作。<br> 8、遍历已标记的懒加载的类，并做初始化操作。<br> 9、处理所有Category，包括Class和Meta Class。<br> 10、初始化所有未初始化的类。</p>
<h6 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h6><p>构造好 class_rw_t 之后，load_images 调用 call_load_methods 就是开始调用类的+load方法和分类的+load方法了。 load_images 在runtime初始化_objc_init就注册到dyld,因此每当有新的镜像image加载时，都会执行load_images进行回调。</p>
<p>load类方法的调用时机比main函数还要靠前。load方法是由系统来调用的，并且在整个程序运行期间，只会调用一次，所以可以在load方法中执行一些只执行一次的操作。</p>
<p>一般Method Swizzling都会放在load方法中执行，这样在执行main函数前，就可以对类方法进行交换。可以确保正式执行代码时，方法肯定是被交换过的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line"></span><br><span class="line">load_images(<span class="keyword">enum</span> dyld_image_states state, <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">            <span class="keyword">const</span> struct dyld_image_info infoList[]) &#123;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会进入 load_images_nolock 来查找 load 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">load_images_nolock</span><span class="params">(<span class="keyword">enum</span> dyld_image_states state,<span class="keyword">uint32_t</span> infoCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> struct dyld_image_info infoList[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = NO;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    i = infoCount;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;</span><br><span class="line">        <span class="keyword">if</span> (!hasLoadMethods(mhdr)) <span class="keyword">continue</span>;</span><br><span class="line">        prepare_load_methods(mhdr);</span><br><span class="line">        found = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 prepare_load_methods 对 load 方法的调用进行准备（将需要调用 load 方法的类添加到一个列表中，后面的小节中会介绍）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 _getObjc2NonlazyClassList 获取所有的类的列表之后，会通过 remapClass 获取类对应的指针，然后调用 schedule_class_load 递归地安排当前类和没有调用 + load 父类进入列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行 add_class_to_loadable_list(cls) 将当前类加入加载列表之前，会先把父类加入待加载的列表，保证父类在子类前调用 load 方法。在将镜像加载到运行时、对 load 方法的准备就绪之后，执行 call_load_methods，开始调用 load 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.//调用所有添加的类和类目的 +load方法</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first.// 类的 +load方法 保证父类在子类前调用。</span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.//类目的+load方法调用 在父类+load方法之后</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br></pre></td></tr></table></figure>

<p>方法的调用流程大概是这样的：</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/call_load_methods%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="call_load_methods方法调用流程图.png">

<p>其中call_class_loads 会从一个待加载的类列表 loadable_classes 中寻找对应的类，然后找到 @selector(load) 的实现并执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行 (*load_method)(cls, SEL_load) 代码就会调用类中的+load方法。<br>至此：Q：load 方法是如何被调用的？<br>A：当 Objective-C 运行时初始化的时候，会通过 dyld_register_image_state_change_handler 在每次有新的镜像加入运行时的时候，进行回调。执行 load_images 将所有包含 load 方法的文件加入列表 loadable_classes ，然后从这个列表中找到对应的 load 方法的实现，调用 load 方法。</p>
<h6 id="loadable-classes是怎么管理的？"><a href="#loadable-classes是怎么管理的？" class="headerlink" title="loadable_classes是怎么管理的？"></a>loadable_classes是怎么管理的？</h6><p>1、ObjC 对于加载的管理，主要使用了两个列表，分别是 loadable_classes 和 loadable_categories。</p>
<p>方法的调用过程也分为两个部分，准备 load 方法和调用 load 方法，我更觉得这两个部分比较像生产者与消费者：</p>
<img src="/blog/runtime%E5%AD%A6%E4%B9%A0%E4%B8%80/loadable_classes%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%A1%E7%90%86.png" class="" title="loadable_classes列表的管理.png">

<p>add_class_to_loadable_list 方法负责将类加入 loadable_classes 集合，而 call_class_loads 负责消费集合中的元素。而对于分类来说，其模型也是类似的，只不过使用了另一个列表 loadable_categories。</p>
<p>2、“生产” loadable_class</p>
<p>3、“消费” loadable_class</p>
<p>关于验证可参考 <a href="https://github.com/draveness/analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md#深入解析-objc-中方法的结构" target="_blank" rel="noopener">https://github.com/draveness/analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md#深入解析-objc-中方法的结构</a> </p>
<p>参考：<a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener">https://halfrost.com/objc_runtime_isa_class/</a><br><a href="https://www.jianshu.com/p/4546f22b2e96" target="_blank" rel="noopener">https://www.jianshu.com/p/4546f22b2e96</a></p>
<p><a href="https://blog.csdn.net/shengpeng3344/article/details/105800310?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1" target="_blank" rel="noopener">https://blog.csdn.net/shengpeng3344/article/details/105800310?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1</a></p>
<p>你真的了解load方法么？<a href="https://blog.csdn.net/u011303663/article/details/51553489" target="_blank" rel="noopener">https://blog.csdn.net/u011303663/article/details/51553489</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
